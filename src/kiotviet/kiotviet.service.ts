import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class KiotVietService {
  private readonly logger = new Logger(KiotVietService.name);
  private readonly baseUrl: string;
  private readonly clientId: string;
  private readonly clientSecret: string;
  private readonly retailerName: string;
  private readonly websiteBranchId = 635934;
  private accessToken: string;

  constructor(
    private configService: ConfigService,
    private httpService: HttpService,
  ) {
    const baseUrl = this.configService.get('KIOT_BASE_URL');
    if (!baseUrl) {
      throw new Error('KIOT_BASE_URL environment variable is not configured');
    }
    this.baseUrl = baseUrl;

    const clientId = this.configService.get('KIOTVIET_CLIENT_ID');
    if (!clientId) {
      throw new Error(
        'KIOTVIET_CLIENT_ID environment variable is not configured',
      );
    }
    this.clientId = clientId;

    const clientSecret = this.configService.get('KIOTVIET_CLIENT_SECRET');
    if (!clientSecret) {
      throw new Error(
        'KIOTVIET_CLIENT_SECRET environment variable is not configured',
      );
    }
    this.clientSecret = clientSecret;

    const retailerName = this.configService.get('KIOTVIET_RETAILER_NAME');
    if (!retailerName) {
      throw new Error(
        'KIOTVIET_RETAILER_NAME environment variable is not configured',
      );
    }
    this.retailerName = retailerName;

    this.logger.log(
      `üè™ Using website branch: C·ª≠a H√†ng Di·ªáp Tr√† (ID: ${this.websiteBranchId})`,
    );
  }

  private async getAccessToken(): Promise<string> {
    if (this.accessToken) return this.accessToken;

    try {
      const tokenUrl = this.configService.get('KIOT_TOKEN');
      const response = await firstValueFrom(
        this.httpService.post(
          tokenUrl,
          {
            client_id: this.clientId,
            client_secret: this.clientSecret,
            grant_type: 'client_credentials',
            scopes: 'PublicApi.Access',
          },
          {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          },
        ),
      );

      this.accessToken = response.data.access_token;
      this.logger.log('‚úÖ KiotViet access token obtained successfully');
      return this.accessToken;
    } catch (error) {
      this.logger.error(
        'Failed to get KiotViet access token:',
        error.response?.data || error,
      );
      throw error;
    }
  }

  // ‚úÖ FIX: Validate branch tr∆∞·ªõc khi t·∫°o customer/order
  async validateBranchId(): Promise<void> {
    const token = await this.getAccessToken();

    try {
      const response = await firstValueFrom(
        this.httpService.get(`${this.baseUrl}/branches`, {
          headers: {
            Authorization: `Bearer ${token}`,
            Retailer: this.retailerName,
          },
        }),
      );

      this.logger.log('Available branches:', response.data.data);

      const validBranch = response.data.data.find(
        (branch) => branch.id === this.websiteBranchId,
      );
      if (!validBranch) {
        throw new Error(
          `‚ùå Branch ID ${this.websiteBranchId} not found! Available branches: ${response.data.data.map((b) => `${b.id}(${b.branchName})`).join(', ')}`,
        );
      }

      this.logger.log('‚úÖ Valid branch found:', validBranch);
    } catch (error) {
      this.logger.error(
        '‚ùå Branch validation failed:',
        error.response?.data || error.message,
      );
      throw error;
    }
  }

  async createCustomer(customerData: {
    name: string;
    phone: string;
    email?: string;
    address?: string;
    province?: string;
    ward?: string;
    district?: string;
  }): Promise<any> {
    const token = await this.getAccessToken();

    const payload = {
      name: customerData.name,
      contactNumber: customerData.phone,
      email: customerData.email || '',
      address:
        `${customerData.address || ''}, ${customerData.ward || ''}, ${customerData.province || ''}`
          .trim()
          .replace(/^,\s*|,\s*$/g, ''),
      wardName: customerData.ward || '',
      locationName: [customerData.province, customerData.district]
        .filter(Boolean)
        .join(' - '),
      comments: `KH√ÅCH H√ÄNG T·ª™ WEBSITE - ${new Date().toLocaleString('vi-VN')}`,
      branchId: 635934,
    };

    try {
      const response = await firstValueFrom(
        this.httpService.post(`${this.baseUrl}/customers`, payload, {
          headers: {
            Authorization: `Bearer ${token}`,
            Retailer: this.retailerName,
            'Content-Type': 'application/json',
          },
        }),
      );

      this.logger.log(
        `‚úÖ Created customer: ${response.data.id} (${response.data.name})`,
      );
      return response.data;
    } catch (error) {
      this.logger.error('‚ùå Create customer failed:', error.response?.data);
      throw error;
    }
  }

  async createOrder(orderData: {
    customerId: number;
    customerName: string;
    items: Array<{
      productId: number;
      productCode: string;
      productName: string;
      quantity: number;
      price: number;
    }>;
    total: number;
    description?: string;
  }): Promise<any> {
    // ‚úÖ Validate branch tr∆∞·ªõc khi t·∫°o
    await this.validateBranchId();

    const token = await this.getAccessToken();

    const orderDetails = orderData.items.map((item) => ({
      productId: item.productId,
      productCode: item.productCode,
      productName: item.productName,
      quantity: item.quantity,
      price: item.price,
      isMaster: true,
    }));

    const websiteNote = `ƒê∆†N H√ÄNG T·ª™ WEBSITE - ${new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })}`;
    const customerNote = orderData.description
      ? ` | Ghi ch√∫ KH: ${orderData.description}`
      : '';
    const finalDescription = `${websiteNote}${customerNote}`;

    const payload = {
      purchaseDate: new Date().toISOString(),
      branchId: this.websiteBranchId, // ‚úÖ SINGLE VALUE cho order API
      discount: 0,
      description: finalDescription,
      method: 'Cash',
      totalPayment: orderData.total,
      customer: {
        id: orderData.customerId,
        name: orderData.customerName,
      },
      orderDetails,
    };

    this.logger.log(
      `üì¶ Creating order for branch: C·ª≠a H√†ng Di·ªáp Tr√† (${this.websiteBranchId})`,
    );
    this.logger.log(`Order payload:`, payload);

    try {
      const response = await firstValueFrom(
        this.httpService.post(`${this.baseUrl}/orders`, payload, {
          headers: {
            Authorization: `Bearer ${token}`,
            Retailer: this.retailerName,
            'Content-Type': 'application/json',
          },
        }),
      );

      this.logger.log(
        `‚úÖ Created KiotViet order: ${response.data.code} (Total: ${orderData.total})`,
      );
      return response.data;
    } catch (error) {
      this.logger.error(
        '‚ùå Failed to create KiotViet order:',
        JSON.stringify(error.response?.data || error.message, null, 2),
      );
      throw error;
    }
  }

  // ‚úÖ Method ƒë·ªÉ handle payment success t·ª´ Sepay
  async handlePaymentSuccess(paymentData: {
    customerName: string;
    phone: string;
    email?: string;
    address?: string;
    items: Array<{
      productId: number;
      productCode: string;
      productName: string;
      quantity: number;
      price: number;
    }>;
    amount: number;
    orderId: string;
    note?: string;
  }): Promise<{ customer: any; order: any }> {
    try {
      this.logger.log(
        `üîÑ Processing payment success for order: ${paymentData.orderId}`,
      );

      // 1. T·∫°o customer tr∆∞·ªõc
      const customer = await this.createCustomer({
        name: paymentData.customerName,
        phone: paymentData.phone,
        email: paymentData.email,
        address: paymentData.address,
      });

      // 2. T·∫°o order v·ªõi customerId t·ª´ step 1
      const order = await this.createOrder({
        customerId: customer.id,
        customerName: customer.name,
        items: paymentData.items,
        total: paymentData.amount,
        description: `Web order #${paymentData.orderId} - ${paymentData.note || ''}`,
      });

      this.logger.log(
        `‚úÖ Successfully processed payment for order: ${paymentData.orderId}`,
      );
      return { customer, order };
    } catch (error) {
      this.logger.error(
        `‚ùå Failed to process payment for order ${paymentData.orderId}:`,
        error.message,
      );
      throw error;
    }
  }

  async testConnection(): Promise<{ success: boolean; message: string }> {
    try {
      await this.validateBranchId();

      return {
        success: true,
        message: `Connected successfully to KiotViet. Using branch: C·ª≠a H√†ng Di·ªáp Tr√† (ID: ${this.websiteBranchId})`,
      };
    } catch (error) {
      return {
        success: false,
        message: `Connection failed: ${error.message}`,
      };
    }
  }

  getBranchInfo(): { id: number; name: string } {
    return {
      id: this.websiteBranchId,
      name: 'C·ª≠a H√†ng Di·ªáp Tr√†',
    };
  }
}
